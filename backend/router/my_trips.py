"""
Travel Plans Management Router
Handles all endpoints for managing user travel plans, including PDF generation
"""
import os
import logging
from typing import List, Optional
from datetime import datetime
from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks, Response
from fastapi.responses import FileResponse
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials

from models.travel_plan_models import (
    UserTravelPlan,
    TravelPlanCreate,
    TravelPlanUpdate,
    TravelPlanQuery,
    TravelPlanSummary,
    TravelPlanResponse,
    TravelPlanStats,
    PDFGenerationRequest,
    PDFGenerationResponse,
    TravelPlanShare,
    TripStatus,
    TripPrivacy
)
from services.travel_plan_service import get_travel_plan_service
from services.pdf_generation_service import get_pdf_generator
from router.auth import get_current_user
from services.auth_service import AuthService

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/my-trips", tags=["My Trips"])
security = HTTPBearer()

# Initialize auth service
auth_service = AuthService()

# Dependency to get current user
async def get_authenticated_user(credentials: HTTPAuthorizationCredentials = Depends(security)):
    """Get current authenticated user"""
    try:
        token_data = auth_service.verify_token(credentials.credentials)
        user = await auth_service.get_user_by_id(token_data.user_id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_401_UNAUTHORIZED,
                detail="Invalid authentication credentials",
                headers={"WWW-Authenticate": "Bearer"},
            )
        return user
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Could not validate credentials",
            headers={"WWW-Authenticate": "Bearer"},
        )


@router.post("/save-plan", response_model=TravelPlanResponse)
async def save_travel_plan(
    plan_data: TravelPlanCreate,
    current_user = Depends(get_authenticated_user)
):
    """
    Save a travel plan generated by the planning system
    """
    try:
        service = get_travel_plan_service()
        
        # Create the travel plan
        travel_plan = await service.create_travel_plan(
            user_id=current_user.id,
            plan_data=plan_data
        )
        
        logger.info(f"Saved travel plan {travel_plan.id} for user {current_user.id}")
        
        return TravelPlanResponse(
            plan=travel_plan,
            can_edit=True,
            can_download=True
        )
        
    except Exception as e:
        logger.error(f"Error saving travel plan: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to save travel plan"
        )


@router.get("/", response_model=List[TravelPlanSummary])
async def get_my_travel_plans(
    status_filter: Optional[str] = None,
    privacy_filter: Optional[str] = None,
    favorite_only: bool = False,
    search: Optional[str] = None,
    limit: int = 20,
    offset: int = 0,
    sort_by: str = "created_at",
    sort_order: str = "desc",
    current_user = Depends(get_authenticated_user)
):
    """
    Get user's travel plans with filtering and pagination
    """
    try:
        service = get_travel_plan_service()
        
        # Build query
        query = TravelPlanQuery(
            status=TripStatus(status_filter) if status_filter else None,
            privacy=TripPrivacy(privacy_filter) if privacy_filter else None,
            favorite_only=favorite_only,
            search_query=search,
            limit=limit,
            offset=offset,
            sort_by=sort_by,
            sort_order=sort_order
        )
        
        travel_plans, total_count = await service.get_user_travel_plans(
            user_id=current_user.id,
            query=query
        )
        
        # Add total count to response headers
        # Note: You might want to return this differently in a real API
        logger.info(f"Retrieved {len(travel_plans)} travel plans for user {current_user.id}")
        
        return travel_plans
        
    except Exception as e:
        logger.error(f"Error retrieving travel plans: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve travel plans"
        )


@router.get("/{plan_id}", response_model=TravelPlanResponse)
async def get_travel_plan(
    plan_id: str,
    current_user = Depends(get_authenticated_user)
):
    """
    Get a specific travel plan by ID
    """
    try:
        service = get_travel_plan_service()
        
        travel_plan = await service.get_travel_plan(
            plan_id=plan_id,
            user_id=current_user.id
        )
        
        if not travel_plan:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Travel plan not found"
            )
        
        # Check if user can edit (owns the plan or has shared edit access)
        can_edit = (
            travel_plan.user_id == current_user.id or
            current_user.id in travel_plan.shared_with
        )
        
        return TravelPlanResponse(
            plan=travel_plan,
            can_edit=can_edit,
            can_download=True
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error retrieving travel plan {plan_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve travel plan"
        )


@router.put("/{plan_id}", response_model=TravelPlanResponse)
async def update_travel_plan(
    plan_id: str,
    updates: TravelPlanUpdate,
    current_user = Depends(get_authenticated_user)
):
    """
    Update a travel plan
    """
    try:
        service = get_travel_plan_service()
        
        updated_plan = await service.update_travel_plan(
            plan_id=plan_id,
            user_id=current_user.id,
            updates=updates
        )
        
        if not updated_plan:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Travel plan not found or access denied"
            )
        
        can_edit = updated_plan.user_id == current_user.id
        
        return TravelPlanResponse(
            plan=updated_plan,
            can_edit=can_edit,
            can_download=True
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error updating travel plan {plan_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update travel plan"
        )


@router.delete("/{plan_id}")
async def delete_travel_plan(
    plan_id: str,
    current_user = Depends(get_authenticated_user)
):
    """
    Delete (archive) a travel plan
    """
    try:
        service = get_travel_plan_service()
        
        success = await service.delete_travel_plan(
            plan_id=plan_id,
            user_id=current_user.id
        )
        
        if not success:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Travel plan not found or access denied"
            )
        
        return {"message": "Travel plan archived successfully"}
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error deleting travel plan {plan_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to delete travel plan"
        )


@router.get("/stats/overview", response_model=TravelPlanStats)
async def get_travel_plan_stats(
    current_user = Depends(get_authenticated_user)
):
    """
    Get user's travel plan statistics
    """
    try:
        service = get_travel_plan_service()
        
        stats = await service.get_travel_plan_stats(
            user_id=current_user.id
        )
        
        return stats
        
    except Exception as e:
        logger.error(f"Error getting travel plan stats: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve travel plan statistics"
        )


@router.post("/{plan_id}/generate-pdf", response_model=PDFGenerationResponse)
async def generate_travel_plan_pdf(
    plan_id: str,
    pdf_request: PDFGenerationRequest,
    background_tasks: BackgroundTasks,
    current_user = Depends(get_authenticated_user)
):
    """
    Generate a PDF for a travel plan
    """
    try:
        service = get_travel_plan_service()
        pdf_generator = get_pdf_generator()
        
        # Get the travel plan
        travel_plan = await service.get_travel_plan(
            plan_id=plan_id,
            user_id=current_user.id
        )
        
        if not travel_plan:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Travel plan not found"
            )
        
        # Set the plan ID in the request
        pdf_request.travel_plan_id = plan_id
        
        # Generate PDF
        pdf_response = await pdf_generator.generate_pdf(
            travel_plan=travel_plan,
            request=pdf_request
        )
        
        if pdf_response.success and pdf_response.file_path:
            # Update travel plan to mark PDF as generated
            await service.update_travel_plan(
                plan_id=plan_id,
                user_id=current_user.id,
                updates=TravelPlanUpdate()  # This will trigger an update for PDF tracking
            )
            
            # Log the PDF generation in background
            background_tasks.add_task(
                log_pdf_generation,
                plan_id,
                current_user.id,
                pdf_response.file_path,
                pdf_response.file_size_mb,
                pdf_response.generation_time_seconds,
                pdf_request
            )
            
            # Create download URL (you might want to implement a proper file serving endpoint)
            pdf_response.pdf_url = f"/api/my-trips/{plan_id}/download-pdf"
        
        return pdf_response
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error generating PDF for travel plan {plan_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to generate PDF"
        )


@router.get("/{plan_id}/download-pdf")
async def download_travel_plan_pdf(
    plan_id: str,
    current_user = Depends(get_authenticated_user)
):
    """
    Download the PDF for a travel plan
    """
    try:
        service = get_travel_plan_service()
        
        # Get the travel plan
        travel_plan = await service.get_travel_plan(
            plan_id=plan_id,
            user_id=current_user.id
        )
        
        if not travel_plan:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Travel plan not found"
            )
        
        # Check if PDF exists
        if not travel_plan.pdf_file_path or not os.path.exists(travel_plan.pdf_file_path):
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="PDF not found. Please generate the PDF first."
            )
        
        # Get filename for download
        filename = os.path.basename(travel_plan.pdf_file_path)
        
        # Return file response
        return FileResponse(
            path=travel_plan.pdf_file_path,
            filename=filename,
            media_type="application/pdf",
            headers={
                "Content-Disposition": f"attachment; filename={filename}"
            }
        )
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error downloading PDF for travel plan {plan_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to download PDF"
        )


@router.post("/{plan_id}/toggle-favorite")
async def toggle_favorite(
    plan_id: str,
    current_user = Depends(get_authenticated_user)
):
    """
    Toggle favorite status of a travel plan
    """
    try:
        service = get_travel_plan_service()
        
        # Get current plan
        travel_plan = await service.get_travel_plan(
            plan_id=plan_id,
            user_id=current_user.id
        )
        
        if not travel_plan:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Travel plan not found"
            )
        
        # Toggle favorite
        updated_plan = await service.update_travel_plan(
            plan_id=plan_id,
            user_id=current_user.id,
            updates=TravelPlanUpdate(favorite=not travel_plan.favorite)
        )
        
        return {
            "message": "Favorite status updated",
            "favorite": updated_plan.favorite if updated_plan else False
        }
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error toggling favorite for travel plan {plan_id}: {str(e)}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to update favorite status"
        )


# Background task functions
async def log_pdf_generation(
    plan_id: str,
    user_id: str,
    file_path: str,
    file_size_mb: float,
    generation_time: float,
    pdf_request: PDFGenerationRequest
):
    """Background task to log PDF generation"""
    try:
        # Here you would log to your travel_plan_pdfs table
        # This is a simplified version - implement based on your database setup
        logger.info(
            f"PDF generated for plan {plan_id} by user {user_id}: "
            f"{file_path} ({file_size_mb}MB, {generation_time}s)"
        )
    except Exception as e:
        logger.error(f"Error logging PDF generation: {str(e)}")


# Auto-save functionality for planning integration
@router.post("/auto-save-from-planning")
async def auto_save_from_planning(
    plan_data: dict,
    current_user = Depends(get_authenticated_user)
):
    """
    Auto-save a travel plan when user generates one from the planning page
    This endpoint will be called automatically after successful plan generation
    """
    try:
        service = get_travel_plan_service()
        
        # Extract data from the planning response
        travel_plan_data = plan_data.get("travel_plan", {})
        original_request = plan_data.get("original_request", {})
        
        # Create a title based on the plan
        title = f"Sri Lanka Trip - {original_request.get('trip_duration_days', 'X')} Days"
        if "daily_itineraries" in travel_plan_data and travel_plan_data["daily_itineraries"]:
            # Try to extract destinations for a better title
            destinations = set()
            for day in travel_plan_data["daily_itineraries"][:3]:  # First 3 days
                if "cluster_name" in day:
                    destinations.add(day["cluster_name"])
            if destinations:
                title = f"Sri Lanka: {', '.join(list(destinations)[:2])}"
                if len(destinations) > 2:
                    title += " & More"
        
        # Create TravelPlanCreate object
        plan_create = TravelPlanCreate(
            title=title,
            description=f"Generated travel plan for {original_request.get('trip_duration_days', 'multiple')} days",
            travel_plan_data=travel_plan_data,
            original_query=original_request.get("query", ""),
            interests=original_request.get("interests", []),
            trip_duration_days=original_request.get("trip_duration_days", 1),
            budget_level=original_request.get("budget_level", "mid_range"),
            trip_type=original_request.get("trip_type", "couple"),
            privacy=TripPrivacy.PRIVATE
        )
        
        # Save the plan
        travel_plan = await service.create_travel_plan(
            user_id=current_user.id,
            plan_data=plan_create
        )
        
        logger.info(f"Auto-saved travel plan {travel_plan.id} from planning system")
        
        return {
            "message": "Travel plan auto-saved successfully",
            "plan_id": travel_plan.id,
            "title": travel_plan.title
        }
        
    except Exception as e:
        logger.error(f"Error auto-saving travel plan: {str(e)}")
        # Don't raise an error here - auto-save should be silent
        return {
            "message": "Auto-save failed",
            "error": str(e)
        }
